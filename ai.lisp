;; the intent was for the ai not to make the impassable barriers, but it makes it useless. disable the barriers in mechanics somehow.

(defun auto-turn (player)
  (dotimes (i 10)
    (dotimes (i *h*)
      (dotimes (j *w*)
        (auto-found i j player)))
    (dotimes (i *h*)
      (dotimes (j *w*)
        (auto-move i j player)))
    (dotimes (i *h*)
      (dotimes (j *w*)
        (auto-buy i j player)))))

(defun chance (odds)
  (< (random (expt 10 6))
     (* (expt 10 6)
        odds)))

(defun auto-found (i j player)
  (let ((unit (gethash (cons i j) *units*)))
    (cond (unit
           (when (equal (unit-player unit) player)
             (if (and (> (unit-moves unit) 0)
                      (not (some #'(lambda (num) (near-a-city? i j num))
                                 (countdown *player-count*)))
                      (chance 1/2))
                 (found-city i j player)))))))

(defun auto-move (i j player)
  (let ((unit (gethash (cons i j) *units*)))
    (cond (unit
           (when (equal (unit-player unit) player)
             ;; have to keep checking the unit is still there, better logic needed
             (if (and (gethash (cons i j) *units*)
                      (> (unit-moves unit) 0)
                      (chance 1/4))
                 (move-unit i j 0 -1))
             (if (and (gethash (cons i j) *units*)
                      (> (unit-moves unit) 0)
                      (chance 1/3))
                 (move-unit i j 0 1))
             (if (and (gethash (cons i j) *units*)
                      (> (unit-moves unit) 0)
                      (chance 1/2))
                 (move-unit i j -1 0))
             (if (and (gethash (cons i j) *units*)
                      (> (unit-moves unit) 0)
                      (chance 2/3))
                 (move-unit i j 1 0)))))))

(defun auto-buy (i j player) ; not player id!
  (let ((unit (gethash (cons i j) *units*))
        (city (gethash (cons i j) *cities*)))
    (if (and (null unit)
             (null city)
             (near-a-city? i j player)
             (equal player
                    (city-player (nearest-city i j)))
             (>= (player-money (gethash player *players*))
                 *unit-cost*)
             (free-neighbours i j)
             (chance 1/10))
        (buy-unit i j player))))

(defun free-neighbours (i j)
  (remove-if #'(lambda (cons)
                 (let ((x (car cons))
                       (y (cdr cons)))
                   (or (not (> *h* x -1))
                       (not (> *w* y -1))
                       (gethash (cons x y) *cities*)
                       ;(gethash (cons x y) *units*) ;; objectively bad, might be locally good
                       )))
             (list (cons i (1+ j))
                   (cons i (1- j))
                   (cons (1+ i) j)
                   (cons (1- i) j))))
